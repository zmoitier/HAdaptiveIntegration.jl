var documenterSearchIndex = {"docs":
[{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Modules = [HAdaptiveIntegration]","category":"page"},{"location":"95-reference/#HAdaptiveIntegration.SEGMENT_GAUSS_O13_N7","page":"Reference","title":"HAdaptiveIntegration.SEGMENT_GAUSS_O13_N7","text":"const SEGMENT_GAUSS_O13_N7\n\nReference: https://www.advanpix.com/2011/11/07/gauss-kronrod-quadrature-nodes-weights/\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#HAdaptiveIntegration.SEGMENT_KRONROD_O23_N15","page":"Reference","title":"HAdaptiveIntegration.SEGMENT_KRONROD_O23_N15","text":"const SEGMENT_KRONROD_O23_N15\n\nReference: https://www.advanpix.com/2011/11/07/gauss-kronrod-quadrature-nodes-weights/\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#HAdaptiveIntegration.SQUARE_COOLS_HAEGEMANS_O7_N21","page":"Reference","title":"HAdaptiveIntegration.SQUARE_COOLS_HAEGEMANS_O7_N21","text":"const SQUARE_COOLS_HAEGEMANS_O8_N25\n\nQuadrature rule embedded in a SQUARE_GAUSS_O9_N25 for the square domain.\n\nReference: https://link.springer.com/article/10.1007/BF01389339\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#HAdaptiveIntegration.SQUARE_GAUSS_O9_N25","page":"Reference","title":"HAdaptiveIntegration.SQUARE_GAUSS_O9_N25","text":"const SQUARE_GAUSS_O9_N25\n\nTensor product quadrature of Gauss-Legendre quadrature with 5 points in each direction.\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#HAdaptiveIntegration.TRIANGLE_LAURIE_O8_N19","page":"Reference","title":"HAdaptiveIntegration.TRIANGLE_LAURIE_O8_N19","text":"const TRIANGLE_LAURIE_O8_N19\n\nReference: https://www.math.unipd.it/~alvise/SETSCUBATURETRIANGLE/laurie/setlauriestandard.m\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#HAdaptiveIntegration.TRIANGLE_RADON_O5_N7","page":"Reference","title":"HAdaptiveIntegration.TRIANGLE_RADON_O5_N7","text":"const TRIANGLE_RADON_O5_N7\n\nReference: https://www.math.unipd.it/~alvise/SETSCUBATURETRIANGLE/radon/setradonstandard.m\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#HAdaptiveIntegration.Domain","page":"Reference","title":"HAdaptiveIntegration.Domain","text":"abstract type Domain{N,T}\n\nAbstract type for integration domains in N dimensions.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#HAdaptiveIntegration.EmbeddedQuadrature","page":"Reference","title":"HAdaptiveIntegration.EmbeddedQuadrature","text":"struct EmbeddedQuadrature{N,T}\n\nAn embedded quadrature rule consisting of a high order quadrature rule and a low order quadrature rule.\n\nFields:\n\nnodes::Vector{SVector{N,T}}: the quadrature nodes\nweights_high::Vector{T}: the quadrature weights for the high order quadrature\nweights_low::Vector{T}: the quadrature weights for the low order quadrature\nlabel::String: a label for the quadrature rule\n\nNote that the low order quadrature uses nodes[1:n] as its nodes, where n = length(weights_low).\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#HAdaptiveIntegration.EmbeddedQuadrature-Tuple{}","page":"Reference","title":"HAdaptiveIntegration.EmbeddedQuadrature","text":"EmbeddedQuadrature(; name::String)\n\nCreate an embedded quadrature rule with the given name.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.HyperRectangle","page":"Reference","title":"HAdaptiveIntegration.HyperRectangle","text":"struct HyperRectangle{N,T} <: Domain{N,T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#HAdaptiveIntegration.Quadrature","page":"Reference","title":"HAdaptiveIntegration.Quadrature","text":"struct Quadrature{N,T}\n\nSimple structure to store a quadrature rule. The structure has three fields:\n\nnodes: a Vector of SVector{N,T} where N is the dimension of the domain and T is the type of the nodes\nweights: a Vector of T where T is the type of the weights\nname: a String to identify the quadrature rule\n\nThe employed naming convention is DOMAIN_RULE_ORDER_NPOINTS` where:\n\nDOMAIN is the name of the domain (e.g. SEGMENT, TRIANGLE, SQUARE),\nRULE is a descriptive name of the quadrature rule (e.g. GAUSS, KRONROD),\nORDER denotes the order of the quadrature rule, and\nNPOINTS is the number of points used\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#HAdaptiveIntegration.Quadrature-Tuple{Function}","page":"Reference","title":"HAdaptiveIntegration.Quadrature","text":"(quad::Quadrature)(fct::Function)\n\nCompute sum(quad.weights .* fct.(quad.nodes)).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.Simplex","page":"Reference","title":"HAdaptiveIntegration.Simplex","text":"struct Simplex{N,T,Np1}\n\nA simplex in N dimensions with Np1=N+1 points of type T.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#HAdaptiveIntegration._decr_multi_idx-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N","page":"Reference","title":"HAdaptiveIntegration._decr_multi_idx","text":"_decr_multi_idx(exponent::NTuple{N,Int64})::Tuple{NTuple{N,Int64},Int} where {N}\n\nDecrement the first positive entry of the multi-index exponent and return the new multi-index and the position of the first positive entry.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration._exponent_to_value-Tuple{Int64, Int64}","page":"Reference","title":"HAdaptiveIntegration._exponent_to_value","text":"_exponent_to_value(tot_deg_max::Int, N::Int)::Dict{NTuple{N,Int64},Rational{Int64}}\n\nGenerate a dictionary mapping multi-indices to the value of the integral of the monomial on the reference simplex.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration._multi_index-Tuple{Int64, Int64}","page":"Reference","title":"HAdaptiveIntegration._multi_index","text":"_multi_index(tot_deg::Int, N::Int)::Vector{NTuple{N,Int}}\n\nGenerate all multi-indices of length N with sum of entries equal to tot_deg.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.check_order-Union{Tuple{T}, Tuple{N}, Tuple{HAdaptiveIntegration.Quadrature{N, T}, Int64}} where {N, T}","page":"Reference","title":"HAdaptiveIntegration.check_order","text":"check_order(quad::Quadrature{N,T}, order::Int)::Bool where {N,T}\n\nCheck if the quadrature rule quad has order order by integrating monomials.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.check_order_square-Union{Tuple{T}, Tuple{N}, Tuple{HAdaptiveIntegration.Quadrature{N, T}, Int64}} where {N, T}","page":"Reference","title":"HAdaptiveIntegration.check_order_square","text":"check_order_square(quad::Quadrature{N,T}, order::Int)::Bool where {N,T}\n\nCheck if the quadrature rule quad has order order by integrating monomials.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.det_jac-Union{Tuple{HAdaptiveIntegration.HyperRectangle{T}}, Tuple{T}} where T","page":"Reference","title":"HAdaptiveIntegration.det_jac","text":"det_jac(s::HyperRectangle)\n\nThe determinant of the Jacobian of the map from the reference simplex to the physical simplex.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.det_jac-Union{Tuple{HAdaptiveIntegration.Simplex{2, T, 3}}, Tuple{T}} where T","page":"Reference","title":"HAdaptiveIntegration.det_jac","text":"det_jac(t::Triangle)\n\nThe determinant of the Jacobian of the map from the reference simplex to the physical simplex.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.det_jac-Union{Tuple{HAdaptiveIntegration.Simplex{3, T, 4}}, Tuple{T}} where T","page":"Reference","title":"HAdaptiveIntegration.det_jac","text":"det_jac(t::Tetrahedron)\n\nThe determinant of the Jacobian of the map from the reference simplex to the physical simplex.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.det_jac-Union{Tuple{HAdaptiveIntegration.Simplex{N, T, Np1}}, Tuple{Np1}, Tuple{T}, Tuple{N}} where {N, T, Np1}","page":"Reference","title":"HAdaptiveIntegration.det_jac","text":"det_jac(s::Simplex)\n\nThe determinant of the Jacobian of the map from the reference simplex to the physical simplex.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.embedded_from_2quad","page":"Reference","title":"HAdaptiveIntegration.embedded_from_2quad","text":"embedded_from_2quad(quad_low, quad_high, name, T = Float64)\n\nCreate an embedded quadrature rule from two quadrature rules. The nodes and weights will be represented as SVector{N,T} and T, respectively.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#HAdaptiveIntegration.integrate-Union{Tuple{T}, Tuple{N}, Tuple{Any, HAdaptiveIntegration.Domain{N, T}}, Tuple{Any, HAdaptiveIntegration.Domain{N, T}, HAdaptiveIntegration.EmbeddedQuadrature{N, T}}, Tuple{Any, HAdaptiveIntegration.Domain{N, T}, HAdaptiveIntegration.EmbeddedQuadrature{N, T}, Any}} where {N, T}","page":"Reference","title":"HAdaptiveIntegration.integrate","text":"integrate(f, s::Simplex[, quad, subdiv_algo; atol = 0, rtol = 0, maxsplit,\nnorm])\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.map_from_ref-Union{Tuple{HAdaptiveIntegration.Simplex{N, T, Np1}}, Tuple{Np1}, Tuple{T}, Tuple{N}} where {N, T, Np1}","page":"Reference","title":"HAdaptiveIntegration.map_from_ref","text":"map_from_ref(s::Simplex)\n\nReturn an anonymous function that maps the reference simplex to the physical simplex. The reference simplex has vertices given by (0,...,0), (1,0,...,0), (0,1,0,...,0), (0,...,0,1).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.reference_hyperrectangle-Tuple{Int64, DataType}","page":"Reference","title":"HAdaptiveIntegration.reference_hyperrectangle","text":"reference_hyperrectangle(N::Int, T::DataType)\n\nReturn the reference HyperRectangle in N dimensions, given by [0, 1]^N.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.reference_simplex","page":"Reference","title":"HAdaptiveIntegration.reference_simplex","text":"reference_simplex(N::Int, T::DataType)\n\nReturn the reference N-simplex. The reference simplex has vertices given by (0,...,0), (1,0,...,0), (0,1,0,...,0), (0,...,0,1).\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#HAdaptiveIntegration.subdivide_cube8-Tuple{HAdaptiveIntegration.HyperRectangle{3}}","page":"Reference","title":"HAdaptiveIntegration.subdivide_cube8","text":"subdivide_cube8(c::Cube)\n\nDivide the square s into four squares by connecting the center of the square to the midpoints of the edges.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.subdivide_segment2-Tuple{HAdaptiveIntegration.HyperRectangle{1}}","page":"Reference","title":"HAdaptiveIntegration.subdivide_segment2","text":"subdivide_segment2(s::Segment)\n\nDivide the segment s into two segments of equal length.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.subdivide_square4-Tuple{HAdaptiveIntegration.HyperRectangle{2}}","page":"Reference","title":"HAdaptiveIntegration.subdivide_square4","text":"subdivide_square4(s::Square)\n\nDivide the square s into four squares by connecting the center of the square to the midpoints of the edges.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.subdivide_tetrahedron8-Tuple{HAdaptiveIntegration.Simplex{3, T, 4} where T}","page":"Reference","title":"HAdaptiveIntegration.subdivide_tetrahedron8","text":"subdivide_tetrahedron8(s::Tetrahedron)\n\nDivide the triangle t into four triangles by connecting the midpoints of the edges.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.subdivide_triangle2-Tuple{HAdaptiveIntegration.Simplex{2, T, 3} where T}","page":"Reference","title":"HAdaptiveIntegration.subdivide_triangle2","text":"subdivide_triangle2(s::Triangle)\n\nDivide the triangle t into two triangles by connecting the midpoints of the edges.\n\n\n\n|| | /|/  +––+\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#HAdaptiveIntegration.subdivide_triangle4-Tuple{HAdaptiveIntegration.Simplex{2, T, 3} where T}","page":"Reference","title":"HAdaptiveIntegration.subdivide_triangle4","text":"subdivide_triangle4(s::Triangle)\n\nDivide the triangle t into four triangles by connecting the midpoints of the edges.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = HAdaptiveIntegration","category":"page"},{"location":"#HAdaptiveIntegration","page":"Home","title":"HAdaptiveIntegration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HAdaptiveIntegration.","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main function of this package is integrate, which computes the integral of a Domain","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nusing HAdaptiveIntegration\nsubtypes(HAdaptiveIntegration.Domain)","category":"page"},{"location":"#Comparisson-with-HCubature.jl","page":"Home","title":"Comparisson with HCubature.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package shares many similarities with HCubature.jl; there are, however, a few important differences:","category":"page"},{"location":"","page":"Home","title":"Home","text":"HAdaptiveIntegration.jl uses tabulated embedded cubature rules such as the ones found in Cubature.jl, whereas HCubature.jl implemented the Genz-Malik algorithm valid axis-aligned rectangles in any dimension.\nHAdaptiveIntegration.jl supports simplicies in low dimensions, whereas HCubature.jl supports axis-aligned rectangles in any dimension.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's start with a simple example using HCubature:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using HCubature, LinearAlgebra\na, b = (0.0, 0.0), (1.0,1.0)\nconst counter = Ref(0)\n# f = x -> (counter[]+=1; 1 / (norm(x) + 1e-0))\nf = x -> (counter[]+=1; cos(20*prod(x)))\nI, E = hcubature(f, a, b)\nprintln(\"I = $I, E = $E, counter = $(counter[])\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, let's do the same with HAdaptiveIntegration:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import HAdaptiveIntegration as HAI\ndomain = HAI.Square(a, b)\ncounter[] = 0\nI, E = HAI.integrate(f, domain)\nprintln(\"I = $I, E = $E, counter = $(counter[])\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lets look at performance now:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BenchmarkTools\ncounter[] = 0\nb1 = @benchmark hcubature($f, $a, $b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"counter[] = 0\nb2 = @benchmark HAI.integrate($f, $domain)","category":"page"}]
}
