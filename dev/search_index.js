var documenterSearchIndex = {"docs":
[{"location":"advanced/#advanced-usage","page":"Advanced usage","title":"Advanced usage","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"We now cover the options available for the integrate function.","category":"page"},{"location":"advanced/#Buffering","page":"Advanced usage","title":"Buffering","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"When calling integrate(f, domain), the package allocates memory for storing the various subregions that are generated during the adaptive integration process. Here is what it looks like in practice:","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"using HAdaptiveIntegration\nusing BenchmarkTools\n\nt = Triangle((0, 0), (1, 0), (0, 1))\nf = x -> 1 / (x[1]^2 + x[2]^2 + 1e-2)\n@benchmark integrate($f, $t)","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"While the overhead associated to these (small) allocations is usually negligible, there are circumstances where one may want to avoid allocations altogether. This can be achieved by passing a buffer to the integrate using allocate_buffer:","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"using HAdaptiveIntegration: allocate_buffer\n\nbuffer = allocate_buffer(f, t)\nintegrate(f,t; buffer)\nb = @benchmark integrate($f, $t; buffer = $buffer)\n@assert b.allocs == 0 # hide\nb # hide","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Provided evaluating f does not allocate, and the buffer has a sufficiently large capacity, integrate will not allocate memory during the integration process, as shown in the benchmark above.","category":"page"},{"location":"advanced/#Embedded-cubature-formulas","page":"Advanced usage","title":"Embedded cubature formulas","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"By default, when calling integrate(f, domain), the package uses a default embedded cubature formula for the given domain by calling default_embedded_cubature. Although these are generally good choices, you can also specify a custom embedded cubature formula by passing it as a keyword argument to integrate. For example, in the case of a triangle, the package defaults to a Radon-Laurie embedded cubature formula of orders 5 and 7 (see the rules_simplex.jl file for more details). If you want e.g. to use an embedded cubature based on the GrundmannMoeller rule of order 13, you can do","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"using HAdaptiveIntegration\nusing HAdaptiveIntegration.Rule: GrundmannMoeller, embedded_cubature\n\nt = Triangle((0, 0), (1, 0), (0, 1))\nf = x -> 1 / (x[1]^2 + x[2]^2 + 1e-2)\nec = embedded_cubature(GrundmannMoeller{2}(13, 11))\nI, E = integrate(f, t; embedded_cubature = ec)","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Which cubature rule is best depends on the function being integrated, as well as on the desired accuracy; as a rule of thumb, higher-order cubature rules will perform better for globally smooth functions f or higher accuracy requirements. Here is a short study on the number of function evaluations required to achieve a given accuracy for the default Radon-Laurie cubature and the GrundmannMoeller cubature rule above:","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"const cc = Ref(0) # a counter for the number of function evaluations\ng = x -> (cc[] += 1; f(x))\nrtol = 1e-2\ncc[] = 0; integrate(g, t; rtol); counter_default = cc[]\ncc[] = 0; integrate(g, t; embedded_cubature = ec, rtol); counter_custom = cc[]\ncounter_default, counter_custom","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"For rtol = 1e-2, we see that the default cubature rule requires fewer function evaluations. However, decreasing rtol changes the balance:","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"rtol = 1e-8\ncc[] = 0; integrate(g, t; rtol); counter_default = cc[]\ncc[] = 0; integrate(g, t; embedded_cubature = ec, rtol); counter_custom = cc[]\ncounter_default, counter_custom","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"This example illustrates that testing is necessary to determine which cubature rule is best for your specific application!","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"tip: Available embedded cubature formulas\nThe list of available embedded cubature formulas is:using HAdaptiveIntegration # hide\nnot_rules = Set([ # hide\n    \"AbstractRule\", # hide\n    \"Rule\", # hide\n    \"EmbeddedCubature\", # hide\n    \"TabulatedEmbeddedCubature\", # hide\n    \"embedded_cubature\", # hide\n    \"orders\", # hide\n]) # hide\nfor name in map(String, names(HAdaptiveIntegration.Rule)) # hide\n    if name ∉ not_rules # hide\n        println(name) # hide\n    end # hide\nend # hide","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"To add a custom embedded quadrature for a given domain, you must write a constructor e.g. my_custom_cubature(args...) that returns a valid EmbeddedCubature object (see the function embedded_cubature in the file Rule/triangle.jl for some examples on how this is done). PRs with new schemes are more than welcome!","category":"page"},{"location":"advanced/#Subdivision-strategies","page":"Advanced usage","title":"Subdivision strategies","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The package uses a default subdivision strategy for the given domain by calling default_subdivision. For example, by default triangles are subdivided into 4 smaller triangles by connecting the midpoints of the edges:","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"using HAdaptiveIntegration\n\nt = Triangle((0, 0), (1, 0), (0, 1))\nsubdiv_algo = HAdaptiveIntegration.default_subdivision(t)","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Here are the subdivided triangles:","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"subdiv_algo(t)","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"But is also possible (and maybe desirable) to split the triangle into 2 smaller triangles instead. The following function accomplishes this:","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"using StaticArrays\n\nfunction subdivide_triangle2(t::Triangle{T}) where {T}\n        a, b, c = t.vertices\n        bc = (b + c) / 2\n        return (Triangle{T}(SVector(bc, a, b)), Triangle{T}(SVector(bc, c, a)))\n    end","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Passing subdivide_triangle2 as the subdiv_algo to integrate will use this instead of the default:","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"f = x -> 1 / (x[1]^2 + x[2]^2 + 1e-2)\nI, E = integrate(f, t; subdiv_algo = subdivide_triangle2)","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Which subdivision strategy is best depends on the function being integrated; for the example presented above, it turns out the default strategy is more efficient!","category":"page"},{"location":"#HAdaptiveIntegration","page":"Home","title":"HAdaptiveIntegration","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HAdaptiveIntegration.jl is a Julia package for approximating integrals of functions over various predefined AbstractDomains. It uses embedded cubature rules to build error estimates, and refines the integration domain by splitting its mesh elements until a certain tolerance is reached. Features include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Adaptive integration over simplices and orthotope of any dimension\nUse of efficient (tabulated) cubatures for low-dimensional simplices (triangle and tetrahedron) and orthotope (rectangle and cuboid)\nSupport for custom cubature rules\nArbitrary precision arithmetic","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add HAdaptiveIntegration","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or, equivalently, via the Julia Pkg API","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"HAdaptiveIntegration\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using HAdaptiveIntegration","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main function exported by this package is integrate(f, Ω), which is used to approximate","category":"page"},{"location":"","page":"Home","title":"Home","text":"I = int_Omega f(x)  mathrmdx","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Omega subset mathbbR^d is a AbstractDomain object, and f colon mathbbR^d to mathbbF is a function. Here is a simple example: first, we define a function,","category":"page"},{"location":"","page":"Home","title":"Home","text":"fct = x -> cis(sum(x)) / (sum(abs2, x) + 1e-2)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Function signature\nThe function f must accept a single argument x which is an abstract vector of length d, the dimension of the domain (concretely, f is called through f(::SVector)). The return type T of f can be any type that supports the operations +(T, T), norm(T), and multiplication by a scalar (e.g. vectors or matrices).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Domains are constructed using the following functions (see their respective docstrings for more details):","category":"page"},{"location":"","page":"Home","title":"Home","text":"In 1 dimension:\nSegment\nIn 2 dimension:\nTriangle\nRectangle\nIn 3 dimension:\nTetrahedron\nCuboid\nIn arbitrary dimension:\nSimplex — en.wikipedia.org/wiki/Simplex\nOrthotope — en.wikipedia.org/wiki/Hyperrectangle","category":"page"},{"location":"#Simplices","page":"Home","title":"Simplices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To integrate the above function over a d-dimensional simplices (triangle, tetrahedron, ...), defined by their vertices, we can use","category":"page"},{"location":"","page":"Home","title":"Home","text":"Triangle\nI, E = integrate(fct, Triangle((0, 0), (1, 0), (0, 1)))\nThe result I is the integral of f over a triangle with vertices (0,0), (1,0), and (0,1), and E is an error estimate.\nTetrahedron\nI, E = integrate(fct, Tetrahedron((0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)))\n4-simplex\nI, E = integrate(\n         fct,\n         Simplex((0, 0, 0, 0), (1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1));\n         rtol=1e-4\n       )\nThe keyword arguments atol and rtol can be used to control the desired absolute and relative error tolerances, respectively.","category":"page"},{"location":"#Orthotopes-(*a.k.a.*-hyperrectangle)","page":"Home","title":"Orthotopes (a.k.a. hyperrectangle)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To integrate the same function over a d-dimensional axis-aligned orthotope (rectangle, cuboid, and hyperrectangle), defined by their low and high corners, we can use","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rectangle\nI, E = integrate(fct, Rectangle((0, 0), (1, 1)))\nCuboid\nI, E = integrate(fct, Cuboid((0, 0, 0), (1, 1, 1)))\n4-orthotope (hyperrectangle)\nI, E = integrate(fct, Orthotope((0, 0, 0, 0), (1, 1, 1, 1)); rtol=1e-4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Related package to integration over an orthotope (hyperrectangle)\nThis package contains rule for an arbitrary d-dimensional orthotope, however:For d=1, you may want to check QuadGk.jl, as it is specialized to do adaptive integration over the segment.\nFor high d, you may want to check HCubature.jl, as it supports adaptive integration over arbitrarily high-dimensional axis-aligned orthotope.\nFor even larger d, you may want to check MCIntegration.jl or Cuba.jl, as they use stochastic method.","category":"page"},{"location":"#Going-further","page":"Home","title":"Going further","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the previous examples we covered the basic usage of the integrate function. There are, however, other options that can be passed to integrate in order to customize various aspects of the underlying algorithm (e.g. passing a different cubature rule, using a buffer to avoid memory allocations, etc.). For more details, see the docstring of the integrate function, as well as the next section on advanced usage.","category":"page"},{"location":"docstrings/#docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/#HAdaptiveIntegration.Domain.AbstractDomain","page":"Docstrings","title":"HAdaptiveIntegration.Domain.AbstractDomain","text":"abstract type AbstractDomain{D,T}\n\nAbstract type for integration domains' in D dimensions with element type T.\n\nType Parameters:\n\nD: dimension of the domain.\nT: element type of the domain.\n\nMandatory methods:\n\nmap_from_reference\n\nUseful (but non-mandatory) methods:\n\nreference_domain\nmap_to_reference\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Domain.Cuboid","page":"Docstrings","title":"HAdaptiveIntegration.Domain.Cuboid","text":"const Cuboid{T} = Orthotope{3,T}\n\nAlias for a 3-dimensional Orthotope of value type T.\n\nConstructors:\n\nCuboid(low_corner, high_corner)\nCuboid{T}(low_corner, high_corner)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Domain.Orthotope","page":"Docstrings","title":"HAdaptiveIntegration.Domain.Orthotope","text":"struct Orthotope{D,T} <: AbstractDomain{D,T}\n\nAxes-aligned Orthotope in D dimensions, with element type T, given by two points low_corner and high_corner. Note that, we must have low_corner .≤ high_corner.\n\nFields:\n\ncorners::SVector{2,SVector{D,T}}: corners[1] = the low corner and corners[2] = the  ]high corner.\n\nInvariants (not check at construction):\n\ncorners[1] .≤ corners[2]\n\nConstructors:\n\nOrthotope(low_corner, high_corner)\nOrthotope{T}(low_corner, high_corner)\nOrthotope(corners::SVector{2,SVector{D,T}})\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Domain.Rectangle","page":"Docstrings","title":"HAdaptiveIntegration.Domain.Rectangle","text":"const Rectangle{T} = Orthotope{2,T}\n\nAlias for a 2-dimensional Orthotope of element type T.\n\nConstructors:\n\nRectangle(low_corner, high_corner)\nRectangle{T}(low_corner, high_corner)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Domain.Segment","page":"Docstrings","title":"HAdaptiveIntegration.Domain.Segment","text":"struct Segment{T} <: AbstractDomain{1,T}\n\nSegment in 1 dimension, with element type T, given by xmin and xmax. Note that, we must have xmin ≤ xmax.\n\nFields:\n\nxmin::T: the low corner.\nxmax::T: the high corner.\n\nInvariants (not check at construction):\n\nxmin ≤ xmax\n\nConstructors:\n\nSegment(xmin, xmax)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Domain.Simplex","page":"Docstrings","title":"HAdaptiveIntegration.Domain.Simplex","text":"struct Simplex{D,T,N} <: AbstractDomain{D,T}\n\nA simplex in D dimensions with N=D+1 vertices of element type T.\n\nFields:\n\nvertices::SVector{N,SVector{D,T}}: vertices of the simplex.\n\nInvariants (not check at construction):\n\nN = D+1\n\nConstructors:\n\nSimplex(vertices...)\nSimplex{T}(vertices...)\nSimplex(vertices::SVector{N,SVector{D,T}})\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Domain.Tetrahedron","page":"Docstrings","title":"HAdaptiveIntegration.Domain.Tetrahedron","text":"const Tetrahedron{T} = Simplex{3,T,4}\n\nAlias for a 3-dimensional Simplex with 4 vertices of element type T.\n\nConstructors:\n\nTetrahedron(a, b, c, d)\nTetrahedron{T}(a, b, c, d)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Domain.Triangle","page":"Docstrings","title":"HAdaptiveIntegration.Domain.Triangle","text":"const Triangle{T} = Simplex{2,T,3}\n\nAlias for a 2-dimensional Simplex with 3 vertices of value type T.\n\nConstructors:\n\nTriangle(a, b, c)\nTriangle{T}(a, b, c)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Domain.combinations-Tuple{Int64, Int64}","page":"Docstrings","title":"HAdaptiveIntegration.Domain.combinations","text":"combinations(n::Int, k::Int)\n\nHelper function to generate all combinations of k elements from 1:n, similar to calling combinations(1:n, k) from Combinatorics.jl.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.dimension-Union{Tuple{Type{<:AbstractDomain{D}}}, Tuple{D}} where D","page":"Docstrings","title":"HAdaptiveIntegration.Domain.dimension","text":"dimension(::Type{<:AbstractDomain{D}}) where {D}\n\nReturn the dimension D of the given domain DOM.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.map_from_reference","page":"Docstrings","title":"HAdaptiveIntegration.Domain.map_from_reference","text":"Φ, μ = map_from_reference(domain::DOM) where {DOM<:AbstractDomain}\n\nReturn Φ and μ where Φ is an anonymous function that maps the reference domain to the physical domain domain and μ is the absolute value of the Jacobian's determinant of the map Φ.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#HAdaptiveIntegration.Domain.map_to_reference","page":"Docstrings","title":"HAdaptiveIntegration.Domain.map_to_reference","text":"map_to_reference(domain::DOM) where {DOM<:AbstractDomain}\n\nReturn an anonymous function that maps the physical domain to the reference domain.\n\nConstraints:\n\nFor Segment, must have xmax > xmin.\nFor Simplex{D}, the vertices must form a valid D-dimensional simplex with non-zero volume).\nFor Orthotope, must have high_corner .> low_corner.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#HAdaptiveIntegration.Domain.reference_domain","page":"Docstrings","title":"HAdaptiveIntegration.Domain.reference_domain","text":"reference_domain(::Type{<:AbstractDomain})\n\nReturn the reference domain for the given domain type. See reference_segment, reference_simplex, and reference_orthotope for more details.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#HAdaptiveIntegration.Domain.reference_orthotope-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T","page":"Docstrings","title":"HAdaptiveIntegration.Domain.reference_orthotope","text":"reference_orthotope(D::Int, T=float(Int))\n\nReturn the reference D-dimensional orthotope [0, 1]ᴰ with element type T.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.reference_segment-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Docstrings","title":"HAdaptiveIntegration.Domain.reference_segment","text":"reference_segment(T=float(Int))\n\nReturn the reference 1-dimensional segment [0, 1] with element type T.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.reference_simplex-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T","page":"Docstrings","title":"HAdaptiveIntegration.Domain.reference_simplex","text":"reference_simplex(D::Int, T=float(Int))\n\nReturn the reference D-dimensional simplex with element type T, which is the convex hull of the N=D+1 points (0,...,0), (1,0,...,0), (0,1,0,...,0), ..., (0,...,0,1).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.subdivide_cuboid-Union{Tuple{Cuboid{T}}, Tuple{T}} where T","page":"Docstrings","title":"HAdaptiveIntegration.Domain.subdivide_cuboid","text":"subdivide_cuboid(c::Cuboid)\n\nDivide the cuboid c into 8 cuboid by connecting the center of the cuboid to the midpoints of the edges.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.subdivide_orthotope-Union{Tuple{Orthotope{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Docstrings","title":"HAdaptiveIntegration.Domain.subdivide_orthotope","text":"subdivide_orthotope(h::Orthotope)\n\nSubdivide the D-orthotope h into 2ᴰ smaller orthotopes by splitting each dimension at its midpoint.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.subdivide_rectangle-Union{Tuple{Rectangle{T}}, Tuple{T}} where T","page":"Docstrings","title":"HAdaptiveIntegration.Domain.subdivide_rectangle","text":"subdivide_rectangle(r::Rectangle)\n\nDivide the rectangle r into 4 squares by connecting the center of the square to the midpoints of the edges.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.subdivide_reference_orthotope-Union{Tuple{Val{D}}, Tuple{T}, Tuple{D}, Tuple{Val{D}, Type{T}}} where {D, T}","page":"Docstrings","title":"HAdaptiveIntegration.Domain.subdivide_reference_orthotope","text":"subdivide_reference_orthotope(::Val{D}, ::Type{T}=float(Int))\n\nLike subdivide_orthotope, but operates on the reference orthotope. Since the output depends only on the dimension D, and the type T used to represent coordinates, this function is generated for each combination of D and T.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.subdivide_reference_simplex-Union{Tuple{Val{D}}, Tuple{T}, Tuple{D}, Tuple{Val{D}, Type{T}}} where {D, T}","page":"Docstrings","title":"HAdaptiveIntegration.Domain.subdivide_reference_simplex","text":"subdivide_reference_simplex(::Val{D}, ::Type{T}=float(Int)) where {D,T}\n\nLike subdivide_simplex, but operates on the reference simplex. Since the output depends only on the dimension D, and the type T used to represent coordinates, this function is generated for each combination of D and T.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.subdivide_segment-Union{Tuple{Segment{T}}, Tuple{T}} where T","page":"Docstrings","title":"HAdaptiveIntegration.Domain.subdivide_segment","text":"subdivide_segment(s::Segment)\n\nSubdivide the 1-dimensional segment s into 2 smaller segments by splitting it at its midpoint.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.subdivide_simplex-Union{Tuple{Simplex{D, T, N}}, Tuple{N}, Tuple{T}, Tuple{D}} where {D, T, N}","page":"Docstrings","title":"HAdaptiveIntegration.Domain.subdivide_simplex","text":"subdivide_simplex(s::Simplex)\n\nSubdivide a D-simplex into 2ᴰ simplices by using the Freudenthal triangulation.\n\nImplements the RedRefinementND algorithm in Simplicial grid refinement: on Freudenthal's algorithm and the optimal number of congruence classes.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.subdivide_tetrahedron-Union{Tuple{Tetrahedron{T}}, Tuple{T}} where T","page":"Docstrings","title":"HAdaptiveIntegration.Domain.subdivide_tetrahedron","text":"subdivide_tetrahedron(t::Tetrahedron)\n\nDivide the tetrahedron t into 8 tetrahedra by connecting the midpoints of the edges.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Domain.subdivide_triangle-Union{Tuple{Triangle{T}}, Tuple{T}} where T","page":"Docstrings","title":"HAdaptiveIntegration.Domain.subdivide_triangle","text":"subdivide_triangle(t::Triangle)\n\nDivide the triangle t into 4 triangles by connecting the midpoints of the edges.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Rule.CUBE_BE115","page":"Docstrings","title":"HAdaptiveIntegration.Rule.CUBE_BE115","text":"Berntsen-Espelid with 115 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.CUBE_BE65","page":"Docstrings","title":"HAdaptiveIntegration.Rule.CUBE_BE65","text":"Berntsen-Espelid with 65 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.CUBE_GM33","page":"Docstrings","title":"HAdaptiveIntegration.Rule.CUBE_GM33","text":"Genz-Malik with 33 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.SEGMENT_GK15","page":"Docstrings","title":"HAdaptiveIntegration.Rule.SEGMENT_GK15","text":"Gauss-Kronrod with 15 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.SEGMENT_GK31","page":"Docstrings","title":"HAdaptiveIntegration.Rule.SEGMENT_GK31","text":"Gauss-Kronrod with 31 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.SEGMENT_GK7","page":"Docstrings","title":"HAdaptiveIntegration.Rule.SEGMENT_GK7","text":"Gauss-Kronrod with 7 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.SQUARE_CH21","page":"Docstrings","title":"HAdaptiveIntegration.Rule.SQUARE_CH21","text":"Cools-Haegemans with 21 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.SQUARE_CH25","page":"Docstrings","title":"HAdaptiveIntegration.Rule.SQUARE_CH25","text":"Cools-Haegemans with 25 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.SQUARE_GM17","page":"Docstrings","title":"HAdaptiveIntegration.Rule.SQUARE_GM17","text":"Genz-Malik with 17 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.TETRAHEDRON_GM35","page":"Docstrings","title":"HAdaptiveIntegration.Rule.TETRAHEDRON_GM35","text":"Grundmann-Möller with 35 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.TRIANGLE_GM19","page":"Docstrings","title":"HAdaptiveIntegration.Rule.TRIANGLE_GM19","text":"Grundmann-Möller with 19 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.TRIANGLE_RL19","page":"Docstrings","title":"HAdaptiveIntegration.Rule.TRIANGLE_RL19","text":"Radon-Laurie with 19 nodes.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#HAdaptiveIntegration.Rule.AbstractRule","page":"Docstrings","title":"HAdaptiveIntegration.Rule.AbstractRule","text":"abstract type AbstractRule{DOM<:AbstractDomain}\n\nAbstract type for a cubature rule on a domain DOM.\n\nType Parameters:\n\nDOM: reference_domain(DOM) gives the reference domain on which the embedded  cubature is assume to be set.\n\nMandatory methods:\n\nembedded_cubature\n\nUseful (but non-mandatory) methods:\n\norders\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Rule.EmbeddedCubature","page":"Docstrings","title":"HAdaptiveIntegration.Rule.EmbeddedCubature","text":"struct EmbeddedCubature{D,T}\n\nAn embedded cubature rule consisting of a high order cubature rule with H nodes and a low order cubature rule with L nodes. Note that the low order cubature uses nodes[1:L] as its nodes. The cubature nodes and weights are assumed to be for the reference domain.\n\nFields:\n\nnodes::Vector{SVector{D,T}}: the cubature nodes.\nweights_high::Vector{T}: the cubature weights for the high order cubature.\nweights_low::Vector{T}: the cubature weights for the low order cubature.\n\nInvariants (check at construction):\n\nlength(nodes) == length(weights_high)\nlength(weights_high) ≥ length(weights_low)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Rule.EmbeddedCubature-Union{Tuple{T}, Tuple{D}, Tuple{Any, AbstractDomain{D, T}}, Tuple{Any, AbstractDomain{D, T}, Any}} where {D, T}","page":"Docstrings","title":"HAdaptiveIntegration.Rule.EmbeddedCubature","text":"(ec::EmbeddedCubature{D,T})(\n    fct, domain::Domain{D,T}, norm=x -> LinearAlgebra.norm(x, Inf)\n) where {D,T}\n\nReturn I_high and norm(I_high - I_low) where I_high and I_low are the result of the high order cubature and the low order cubature on domain. The function fct must take a SVector{D,T} to a return type K, and K must support the multiplication by a scalar and the addition. Note that there is no check, beyond compatibility of dimension and type, that the embedded cubature is for the right domain.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Rule.GenzMalik","page":"Docstrings","title":"HAdaptiveIntegration.Rule.GenzMalik","text":"struct GenzMalik{D} <: AbstractRule{Orthotope{D}}\n\nEmbedded cubature rule for a D-orthotope of high order 7 and low order 5.\n\nType Parameters:\n\nD: The dimension of the orthotope.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Rule.GrundmannMoeller","page":"Docstrings","title":"HAdaptiveIntegration.Rule.GrundmannMoeller","text":"struct GrundmannMoeller{D} <: AbstractRule{Simplex{D}}\n\nEmbedded cubature rule for a D-simplex.\n\nType Parameters:\n\nD: The dimension of the simplex.\n\nFields:\n\norder_high::Int: the high order of the rule.\norder_low::Int: the low order of the rule.\n\nInvariants (check at construction):\n\norder_high and order_low must be odd.\nmust have order_high > order_low ≥ 1.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Rule.RadonLaurie","page":"Docstrings","title":"HAdaptiveIntegration.Rule.RadonLaurie","text":"struct RadonLaurie <: AbstractRule{Simplex{2}}\n\nEmbedded cubature rule for a 2-simplex (a.k.a a triangle) of high order 8 and low order 5.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Rule.TabulatedEmbeddedCubature","page":"Docstrings","title":"HAdaptiveIntegration.Rule.TabulatedEmbeddedCubature","text":"@kwdef struct TabulatedEmbeddedCubature{DOM<:AbstractDomain} <: AbstractRule{DOM}\n\nAn embedded cubature rule consisting of a high order cubature rule and a low order cubature rule. Note that the low order cubature uses nodes[1:L] as its nodes where L is the length of the weights_low. The cubature nodes and weights are assumed to be for the reference domain (use the reference_domain function to get the reference domain).\n\nFields:\n\ndescription::String: description of the embedded cubature.\nreference::String: where the values are found.\norder_high::Int: order of the high order cubature.\norder_low::Int: order of the low order cubature.\nprecision::Int: number of significant digits on the node and weight values, 10^-precision give the relative precision of the values.\nnodes::Vector{Vector{String}}: the cubature nodes.\nweights_high::Vector{String}: the cubature weights for the high order cubature.\nweights_low::Vector{String}: the cubature weights for the low order cubature.\n\nInvariants (check at construction):\n\nlength(nodes) == length(weights_high)\nlength(weights_high) ≥ length(weights_low)\norder_high ≥ order_low ≥ 0\nprecision ≥ 0\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HAdaptiveIntegration.Rule.embedded_cubature-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T","page":"Docstrings","title":"HAdaptiveIntegration.Rule.embedded_cubature","text":"embedded_cubature(ar::AbstractRule, T=float(Int))\n\nembedded_cubature(nodes, weights_high, weights_low, T=float(Int))\n\nConstruct the embedded cubature with element type T from a subtype of AbstractRule or from a vector of nodes and two vectors of weights for the high and low order cubature, with element type T. The list of AbstractRule's subtype are:\n\nTabulatedEmbeddedCubature\nGrundmannMoeller\nRadonLaurie\nGenzMalik\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.Rule.orders-Tuple{TabulatedEmbeddedCubature}","page":"Docstrings","title":"HAdaptiveIntegration.Rule.orders","text":"orders(rule::AR) where {AR<:AbstractRule}\n\nReturn the high and low order of the embedded cubature rule.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.allocate_buffer-Union{Tuple{DOM}, Tuple{Any, DOM}, Tuple{Any, DOM, EmbeddedCubature}} where DOM<:AbstractDomain","page":"Docstrings","title":"HAdaptiveIntegration.allocate_buffer","text":"allocate_buffer(fct, domain, ec=default_embedded_cubature(domain))\n\nAllocate and return a buffer that can be passed to the integrate function to improve performance by reducing memory allocations when integrate is called multiple times.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.default_embedded_cubature-Union{Tuple{Segment{T}}, Tuple{T}} where T","page":"Docstrings","title":"HAdaptiveIntegration.default_embedded_cubature","text":"default_embedded_cubature(domain::DOM) where {DOM<:AbstractDomain}\n\nReturn a default embedded cubature for the domains:\n\ndimension 1:\nSegment: SEGMENT_GK15\ndimension 2:\nTriangle: TRIANGLE_RL19\nRectangle: SQUARE_CH25\ndimension 3:\nTetrahedron: TETRAHEDRON_GM35\nCuboid: CUBE_BE65\ndimension d:\nSimplex: GrundmannMoeller{d}(7, 5)`\nOrthotope: GenzMalik{d}()\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.default_subdivision-Tuple{Segment}","page":"Docstrings","title":"HAdaptiveIntegration.default_subdivision","text":"default_subdivision(domain::DOM) where {DOM<:AbstractDomain}\n\nReturn the default algorithm to subdivide domain.\n\ndimension 1:\nSegment: subdivide_segment\ndimension 2:\nTriangle: subdivide_triangle\nRectangle: subdivide_rectangle\ndimension 3:\nTetrahedron: subdivide_tetrahedron\nCuboid: subdivide_cuboid\ndimension d:\nSimplex: subdivide_simplex\nOrthotope: subdivide_orthotope\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HAdaptiveIntegration.integrate-Union{Tuple{RETURN_BUF}, Tuple{T}, Tuple{D}, Tuple{Any, AbstractDomain{D, T}}} where {D, T, RETURN_BUF}","page":"Docstrings","title":"HAdaptiveIntegration.integrate","text":"integrate(\n    fct,\n    domain::AbstractDomain{D,T};\n    embedded_cubature::EmbeddedCubature{D,T}=default_embedded_cubature(domain),\n    subdiv_algo=default_subdivision(domain),\n    buffer=nothing,\n    norm=x -> LinearAlgebra.norm(x, Inf),\n    atol=zero(T),\n    rtol=(atol > zero(T)) ? zero(T) : sqrt(eps(T)),\n    maxsubdiv=8192 * 2^D,\n    return_buffer=Val(false),\n) where {D,T}\n\nReturn I and E where I is the integral of the function fct over domain and E is an error estimate.\n\nArguments\n\nfct: a function that must take a SVector{D,T} to a return type K, with K must  support the multiplication by a scalar of type T and the addition.\ndomain::AbstractDomain{D,T}: the integration domain. Currently, we support Segment, Triangle, Rectangle, Tetrahedron, Cuboid, d-dimensional Simplex, and d-dimensional Orthotope.\n\nOptional arguments\n\nembedded_cubature::EmbeddedCubature{D,T}=default_embedded_cubature(domain): the embedded cubature,  each supported domain has a default_embedded_cubature.\nsubdiv_algo=default_subdivision(domain): the subdivision algorithm, each domain has a default_subdivision.\nbuffer=nothing: heap use to do the adaptive algorithm, can be allocated using  allocate_buffer, which might result in performance gain if multiple call to  integrate is perform.\nnorm=x -> LinearAlgebra.norm(x, Inf): norm used to estimate the error.\natol=zero(T): absolute tolerance.\nrtol=(atol > zero(T)) ? zero(T) : sqrt(eps(T)): relative tolerance.\nmaxsubdiv=8192 * 2^D: maximum number of subdivision.\nreturn_buffer=Val(false): if Val(true), the buffer used for the computation is also  returned.\n\n\n\n\n\n","category":"method"}]
}
